#!/usr/bin/node

const path = require('path')
const fs = require('fs')
const os = require('os')
const execa = require('execa')
const {Octokit} = require('@octokit/rest')
const JiraApi = require('jira-client')
const chalk = require('chalk')

const CONFIG = JSON.parse(fs.readFileSync(path.resolve(os.homedir(), '.gh-wrapper.json'), 'utf-8'))
const BRANCH_NAME_PATTERN = /^pr\/([a-zA-Z0-9-]+)\/([0-9]+)$/i
const COMMIT_MESSAGE_PATTERN = /^(LPS-[0-9]+)[ ]*(.*)$/i

const octokit = new Octokit({ auth: CONFIG.GITHUB_TOKEN })

const jira = new JiraApi({
  protocol: 'https',
  host: CONFIG.JIRA_URL,
  username: CONFIG.JIRA_USER,
  password: CONFIG.JIRA_PASSWORD,
  strictSSL: true,
  apiVersion: '2',
});

const getLocalRepo = async () => {
  const data = /:([^\/]+)\/([^\.]+)\.git$/.exec(
    (await execa.command('git remote get-url origin')).stdout,
  );

  return [data[1], data[2]];
}

const listPullRequests = async () => {
  let [localOwner, repo] = await getLocalRepo();
  owner = process.argv[3] || localOwner;

  const {data: prs} = await octokit.pulls.list({ owner, repo })

  prs.forEach(pr => {
    const parts = []

    if (pr.labels.length) {
      if (pr.labels.some(label => label.name.endsWith(' failure'))) {
        parts.push(chalk.bold.red('●'))
      } else if (pr.labels.some(label => label.name.endsWith(' pending'))) {
        parts.push(chalk.bold.yellow('●'))
      } else if (pr.labels.every(label => label.name.endsWith(' success'))) {
        parts.push(chalk.bold.green('✔'))
      } else {
        parts.push(chalk.bold.blue('?'))
      }
    }

    parts.push(chalk.dim(`#${pr.number}`));

    if (COMMIT_MESSAGE_PATTERN.test(pr.title)) {
      const [, issueNumber, message] = COMMIT_MESSAGE_PATTERN.exec(pr.title)
      parts.push(chalk.dim(issueNumber))
      parts.push(message)
    } else {
      parts.push(pr.title);
    }

    parts.push(chalk.dim(`(@${pr.user.login})`))

    process.stdout.write(parts.join(' ') + '\n')
  })
}

const checkoutPullRequest = async () => {
  let [owner, repo] = await getLocalRepo();
  let number = parseInt(process.argv[4] || process.argv[3], 10);
  owner = process.argv[4] ? process.argv[3] : owner;

  const {data: prs} = await octokit.pulls.list({ owner, repo })
  const pr = prs.find(pr => pr.number === number)

  if (!pr) {
    console.log(`PR ${owner}/${repo}/${number} not found`)
  } else {
    await execa.command(`git pr ${pr.html_url}`)
    await execa.command(`git branch --move pr/${owner}/${pr.number}`)
  }
}

const sendPullRequest = async () => {
  const {stdout: title} = await execa.command('git log -1 --pretty=%s')
  const {stdout: branch} = await execa.command('git rev-parse --abbrev-ref HEAD')
  const [localOwner, repo] = await getLocalRepo();
  const targetOwner = process.argv[3];

  await execa.command(`git push --force origin ${branch}`)

  const targetPR = await octokit.pulls.create({
    owner: targetOwner,
    repo,
    title,
    head: `${localOwner}:${branch}`,
    base: 'master'
  });

  if (targetOwner === 'liferay-echo') {
    await octokit.issues.createComment({
      owner: targetOwner,
      repo,
      issue_number: targetPR.data.number,
      body: 'ci:forward'
    })
  }

  if (BRANCH_NAME_PATTERN.test(branch)) {
    const data = BRANCH_NAME_PATTERN.exec(branch)

    const sourceOwner = data[1];
    const sourceNumber = data[2];

    const sourcePR = await octokit.pulls.get({
      owner: sourceOwner,
      pull_number: sourceNumber,
      repo,
    })

    await octokit.issues.createComment({
      owner: targetOwner,
      repo,
      issue_number: targetPR.data.number,
      body: `/cc @${sourcePR.data.user.login}`
    })

    await octokit.issues.createComment({
      owner: sourceOwner,
      repo,
      issue_number: sourceNumber,
      body: targetPR.data.html_url
    })

    await octokit.pulls.update({
      owner: sourceOwner,
      repo,
      pull_number: sourceNumber,
      state: 'closed'
    })
  }

  await execa.command('git checkout master')
  await execa.command(`git branch -D ${branch}`)

  console.log(targetPR.data.html_url)

  if (COMMIT_MESSAGE_PATTERN.test(title)) {
    const [,issueId] = COMMIT_MESSAGE_PATTERN.exec(title);

    console.log(`https://${CONFIG.JIRA_URL}/browse/${issueId}`);

    await jira.updateIssue(issueId, {
      fields: {
        customfield_10421: targetPR.data.html_url
      }
    })

    if (CONFIG.GITHUB_USER_TO_JIRA_USER[targetOwner]) {
      await jira.updateAssignee(
        issueId,
        CONFIG.GITHUB_USER_TO_JIRA_USER[targetOwner]
      )
    } else {
      console.log(`No JIRA user found for ${targetOwner}`)
    }
  }
}

switch (process.argv[2]) {
  case 'checkout-pull-request': checkoutPullRequest(); break;
  case 'list-pull-requests': listPullRequests(); break;
  case 'send-pull-request': sendPullRequest(); break;
  default: break;
}
