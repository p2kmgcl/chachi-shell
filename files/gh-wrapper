#!/usr/bin/node

const path = require('path')
const fs = require('fs')
const os = require('os')
const execa = require('execa')
const {Octokit} = require('@octokit/rest')
const JiraApi = require('jira-client')
const chalk = require('chalk')

const printHelp = () => console.log(`
Usage: gh-wrapper <command> [options]...
Custom list of github and jira related commands currently
customized to behave as an ordinary Liferay workflow.

*About [username]*: in Liferay, we make PRs to forked repos instead of using
the upstream repository. Because of this, if [username] is not specified in
some command, it defaults to the *origin* remote instead of upstream.

    list-pull-requests [username]

        List existing pull requests. Tries to parse the Liferay CI progress
        status based on the tags that have been added to each pull request.

    checkout-pull-request [username] <number>

        Checkouts the given PR number locally with the
        pr/username/number format.

    send-pull-request <username>

        Sends a pull request to the given username (no default username used
        on this case) following these steps:

        1. Force pushes the current branch to origin.
        2. Creates a PR merging the uploaded branch to username's master,
           using the last commit message as PR title.
        3. If userame is 'liferay-echo' (the user we use to run the CI and merge
           PRs into upstream), it adds a 'ci:forward' comment to trigger tests.
        4. If the branch name matches the pr/username/number pattern:
           a. Adds a comment to the new PR mentioning the user who created the
              original one.
           b. Adds a comment to the old PR with a reference to the new one.
           c. Closes the old PR.
        5. Locally checkouts master branch and removes the PR branch.
        6. If a jira ticket id is found in the PR title, it updates the ticket
           with the new PR url and tries to assign the ticket to the associated
           GITHUB_USER_TO_JIRA_USER.

# Config

gh-wrapper uses a  ~/.gh-wrapper.json configuration file:

{
  // Required for github authentication. Generate a new personal token here:
  // https://github.com/settings/tokens
  "GITHUB_TOKEN": "",

  // Required for jira authentication
  "JIRA_URL": "issues.liferay.com",
  "JIRA_USER": "pablo.molina",
  "JIRA_PASSWORD": "",

  // Maps github usernames to jira usernames. Used for updating tickets when
  // sending PRs.
  "GITHUB_USER_TO_JIRA_USER": {
    "liferay-echo": "team-echo",
    "p2kmgcl": "pablo.molina"
  }
}`);

const CONFIG = JSON.parse(fs.readFileSync(path.resolve(os.homedir(), '.gh-wrapper.json'), 'utf-8'))
const BRANCH_NAME_PATTERN = /^pr\/([a-zA-Z0-9-]+)\/([0-9]+)$/i
const COMMIT_MESSAGE_PATTERN = /^(LPS-[0-9]+)[ ]*(.*)$/i

const octokit = new Octokit({ auth: CONFIG.GITHUB_TOKEN })

const jira = new JiraApi({
  protocol: 'https',
  host: CONFIG.JIRA_URL,
  username: CONFIG.JIRA_USER,
  password: CONFIG.JIRA_PASSWORD,
  strictSSL: true,
  apiVersion: '2',
});

const getLocalRepo = async () => {
  const data = /:([^\/]+)\/([^\.]+)\.git$/.exec(
    (await execa.command('git remote get-url origin')).stdout,
  );

  return [data[1], data[2]];
}

const listPullRequests = async () => {
  let [localOwner, repo] = await getLocalRepo();
  owner = process.argv[3] || localOwner;

  const {data: prs} = await octokit.pulls.list({ owner, repo })

  prs.forEach(pr => {
    const parts = []

    if (pr.labels.length) {
      if (pr.labels.some(label => label.name.endsWith(' failure'))) {
        parts.push(chalk.bold.red('●'))
      } else if (pr.labels.some(label => label.name.endsWith(' pending'))) {
        parts.push(chalk.bold.yellow('●'))
      } else if (pr.labels.every(label => label.name.endsWith(' success'))) {
        parts.push(chalk.bold.green('✔'))
      } else {
        parts.push(chalk.bold.blue('?'))
      }
    }

    parts.push(chalk.dim(`#${pr.number}`));

    if (COMMIT_MESSAGE_PATTERN.test(pr.title)) {
      const [, issueNumber, message] = COMMIT_MESSAGE_PATTERN.exec(pr.title)
      parts.push(chalk.dim(issueNumber))
      parts.push(message)
    } else {
      parts.push(pr.title);
    }

    parts.push(chalk.dim(`(@${pr.user.login})`))

    process.stdout.write(parts.join(' ') + '\n')
  })
}

const checkoutPullRequest = async () => {
  let [owner, repo] = await getLocalRepo();
  let number = parseInt(process.argv[4] || process.argv[3], 10);
  owner = process.argv[4] ? process.argv[3] : owner;

  const {data: prs} = await octokit.pulls.list({ owner, repo })
  const pr = prs.find(pr => pr.number === number)

  if (!pr) {
    console.log(`PR ${owner}/${repo}/${number} not found`)
  } else {
    await execa.command(`git pr ${pr.html_url}`)
    await execa.command(`git branch --move pr/${owner}/${pr.number}`)
  }
}

const sendPullRequest = async () => {
  const {stdout: title} = await execa.command('git log -1 --pretty=%s')
  const {stdout: branch} = await execa.command('git rev-parse --abbrev-ref HEAD')
  const [localOwner, repo] = await getLocalRepo();
  const targetOwner = process.argv[3];

  await execa.command(`git push --force origin ${branch}`)

  const targetPR = await octokit.pulls.create({
    owner: targetOwner,
    repo,
    title,
    head: `${localOwner}:${branch}`,
    base: 'master'
  });

  if (targetOwner === 'liferay-echo') {
    await octokit.issues.createComment({
      owner: targetOwner,
      repo,
      issue_number: targetPR.data.number,
      body: 'ci:forward'
    })
  }

  if (BRANCH_NAME_PATTERN.test(branch)) {
    const data = BRANCH_NAME_PATTERN.exec(branch)

    const sourceOwner = data[1];
    const sourceNumber = data[2];

    const sourcePR = await octokit.pulls.get({
      owner: sourceOwner,
      pull_number: sourceNumber,
      repo,
    })

    await octokit.issues.createComment({
      owner: targetOwner,
      repo,
      issue_number: targetPR.data.number,
      body: `/cc @${sourcePR.data.user.login}`
    })

    await octokit.issues.createComment({
      owner: sourceOwner,
      repo,
      issue_number: sourceNumber,
      body: targetPR.data.html_url
    })

    await octokit.pulls.update({
      owner: sourceOwner,
      repo,
      pull_number: sourceNumber,
      state: 'closed'
    })
  }

  await execa.command('git checkout master')
  await execa.command(`git branch -D ${branch}`)

  console.log(targetPR.data.html_url)

  if (COMMIT_MESSAGE_PATTERN.test(title)) {
    const [,issueId] = COMMIT_MESSAGE_PATTERN.exec(title);

    console.log(`https://${CONFIG.JIRA_URL}/browse/${issueId}`);

    await jira.updateIssue(issueId, {
      fields: {
        customfield_10421: targetPR.data.html_url
      }
    })

    if (CONFIG.GITHUB_USER_TO_JIRA_USER[targetOwner]) {
      await jira.updateAssignee(
        issueId,
        CONFIG.GITHUB_USER_TO_JIRA_USER[targetOwner]
      )
    } else {
      console.log(`No JIRA user found for ${targetOwner}`)
    }
  }
}

switch (process.argv[2]) {
  case 'checkout-pull-request': checkoutPullRequest(); break;
  case 'list-pull-requests': listPullRequests(); break;
  case 'send-pull-request': sendPullRequest(); break;
  default: printHelp(); break;
}
